#!/usr/bin/perl
use strict;
use Plack::Runner;

sub version {
    require Starman;
    print "Starman $Starman::VERSION\n";
}

my $preload_app;

require Getopt::Long;
Getopt::Long::Configure("no_ignore_case", "no_auto_abbrev", "pass_through");
Getopt::Long::GetOptions(
    "preload-app"      => \$preload_app,
);

my @args = (server => 'Starman', env => 'deployment', version_cb => \&version);
if (!$preload_app) {
    push @args, 'loader' => 'Delayed';
}

my @argv = @ARGV;

my $runner = Plack::Runner->new(@args);
$runner->parse_options(@argv);
$runner->set_options(argv => \@argv);
$runner->run;

__END__

=head1 NAME

starman - Starman launcher

=head1 SYNOPSIS

  starman --listen :5001 --listen /tmp/starman.sock
  starman --workers 32 --port 8080
  starman --min_spare_severs 2 --max_spare_servers 4 --max_servers 10

=head1 OPTIONS

=over 4

=item -l, --listen

  --listen HOST:PORT --listen :PORT --listen UNIX_SOCKET

Specifies the TCP address, ports and UNIX domain sockets to bind to
wait for requests. You can repeat as many times as you want and mix
TCP and UNIX domain sockets.

Defaults to any IP address and port 5000.

=item --host

  --host 127.0.0.1

Specifies the local address to bind to.

This option is for compatibility with L<plackup> and you're
recommended to use C<--listen> instead.

=item --port

  --port 8080

Specifies the local port to listen on.

This option is for compatibility with L<plackup> and you're
recommended to use C<--listen> instead.

=item -S, --socket

  -S /tmp/starman.sock

Specifies the path to a UNIX domain socket to listen on.

This option is for compatibility with L<plackup> and you're
recommended to use C<--listen> instead.

=item --workers

Specifies the number of worker processes. Defaults to 5.

Starman by default sets up other spare server configuration based on this
workers value, making sure there are B<always only> C<N> worker
processes running. So even if there're no idle workers, Starman won't
spawn off spare processes, giving you control over the memory usage etc, at the
expense of either wasting memory with excessive spare workers during quiet
periods, or struggling during busy periods.  Alternatively, you can use the
min_spare_servers, max_spare_servers and max_servers options.

=item --min_spare_servers

Specifies the minimum number of spare worker processes to keep alive.  Similar
to Apache's MinSpareServers directive.

=item --max_spare_servers

Specifies the maximum number of spare worker processes to allow before some are
killed.  Similar to Apache's MaxSpareServers directive.

=item --max_servers

Specifies the maximum number of worker processes which can exist; used in 
conjunction with min/max_spare_servers, you can give Starman the flexibility 
to start more worker processes as required when the number of requests
warrants it, without worrying about the numebr of workers becoming high enough
to swamp your machine.


=item --backlog

Specifies the number of pending connections (listen queue size) of listener 
sockets.  Defaults to 1024.

On production systems, setting a very low value can allow failover on
a frontend proxy (like nginx) to happen more quickly, if you have
multiple Starman clusters.

If you're doing simple benchmarks and getting connection errors,
increasing this parameter can help avoid them. You should also
consider increasing C<net.core.somaxconn>. Note that this is not
recommended for real production systems if you have another cluster to
failover/load balance to (see above).

=item --max-requests

Maximum requests to handle per worker process before it exits and another
replaces it. Defaults to 1000.  This is primarily useful to limit the impact of
any potential memory leaks.

=item --preload-app

This option lets Starman preload the specified PSGI application in the
master parent process before preforking children. This allows memory
savings with copy-on-write memory management. When not set (default),
forked children load the application in the initialization hook.

Enabling this option can cause bad things happen when resources like
sockets or database connections are opened at load time by the master
process and shared by multiple children.

Since Starman 0.2000, this option defaults to false, and you should
explicitly set this option to preload the application in the master
process.

Alternatively, you can use -M command line option (plackup's common
option) to preload the I<modules> rather than the <application>
itself.

  starman -MCatalyst -MDBIx::Class myapp.psgi

will load the modules in the master process for memory savings with
CoW, but the actual loading of C<myapp.psgi> is done per children,
making resource management such as database connections safer.

If you enable this option, sending a C<HUP> signal to the master process
I<will not> pick up any code changes you make. See L</SIGNALS> for
details.

=item --disable-keepalive

Disable Keep-alive persistent connections. It is an useful workaround
if you run Starman behind a broken frontend proxy that tries to pool
more connections than the configured number of backend workers (i.e. 
Apache mpm_prefork + mod_proxy).

=item --keepalive-timeout

The number of seconds Starman will wait for a subsequent request
before closing the connection if Keep-alive persistent connections
are enabled. Setting this to a high value may cause performance
problems on heavily loaded servers. The higher the timeout, the
more backend workers will be kept occupied waiting on connections
with idle clients.

Defaults to 1.

=item --user

To listen on a low-numbered (E<lt>1024) port, it will be necessary to
start the server as root. Use the C<--user> option to specify a userid
or username that the server process should switch to after binding to
the port.

Defaults to the current userid.

=item --group

Specify the group id or group name that the server should switch to after
binding to the port.  This option is usually used with C<--user>.

Defaults to the current group id.

=item --pid

Specify the pid file path. Use it with C<-D|--daemonize> option,
described in C<plackup -h>.

=item --error-log

Specify the pathname of a file where the error log should be written.
This enables you to still have access to the errors when using C<--daemonize>.

=back

Starman passes through other options given to L<Plack::Runner>, the
common backend that L<plackup> uses, so the most options explained in
C<plackup -h> such as C<--access-log> or C<--daemonize> works fine in
starman too.

C<starman> command automatically sets the environment (C<-E>) to the
value of I<deployment>.

Setting the environment variable C<STARMAN_DEBUG> to 1 makes the
Starman server runninng in the debug mode.

=cut

=head1 SIGNALS

=over 4

=item HUP

Sending a C<HUP> signal to the master process will restart all the workers
gracefully (meaning the currently running requests will shut down once
the request is complete), and by default, the workers will pick up the
code changes you make by reloading the application.

If you enable C<--preload-app> option, however, the code will be only
loaded in the startup process and will not pick up the code changes
you made. If you want to preload the app I<and> do graceful restarts
by reloading the code changes, you're recommended to use
L<Server::Starter>, configured to send C<QUIT> signal when superdaemon
receives C<HUP>, i.e:

    start_server --port 8080 --signal-on-hup=QUIT -- starman --preload-app myapp.psgi

=item TTIN, TTOU

Sending a C<TTIN> signal to the master process will dynamically increase
the number of workers, and a C<TTOU> signal will decrease it.

=item INT, TERM

Sending C<INT> or C<TERM> signals to the master process will kill all
the workers immediately and shut down the server.

=item QUIT

Sending a C<QUIT> signal to the master process will gracefully shutdown
the workers (meaning the currently running requests will shut down
once the request is complete).

=back

=head1 SEE ALSO

L<Starman>

=cut
